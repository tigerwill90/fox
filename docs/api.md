<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# fox

```go
import "github.com/tigerwill90/fox"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func CleanPath\(p string\) string](<#CleanPath>)
- [func DefaultHandleRecovery\(c Context, \_ any\)](<#DefaultHandleRecovery>)
- [func DefaultMethodNotAllowedHandler\(c Context\)](<#DefaultMethodNotAllowedHandler>)
- [func DefaultNotFoundHandler\(c Context\)](<#DefaultNotFoundHandler>)
- [func DefaultOptionsHandler\(c Context\)](<#DefaultOptionsHandler>)
- [func ErrNotSupported\(\) error](<#ErrNotSupported>)
- [func FixTrailingSlash\(path string\) string](<#FixTrailingSlash>)
- [func NewTestContext\(w http.ResponseWriter, r \*http.Request, opts ...GlobalOption\) \(\*Router, \*TestContext\)](<#NewTestContext>)
- [func SplitHostPath\(url string\) \(host, path string\)](<#SplitHostPath>)
- [type ClientIPResolver](<#ClientIPResolver>)
- [type ClientIPResolverFunc](<#ClientIPResolverFunc>)
  - [func \(f ClientIPResolverFunc\) ClientIP\(c Context\) \(\*net.IPAddr, error\)](<#ClientIPResolverFunc.ClientIP>)
- [type Context](<#Context>)
- [type ContextCloser](<#ContextCloser>)
- [type GlobalOption](<#GlobalOption>)
  - [func DefaultOptions\(\) GlobalOption](<#DefaultOptions>)
  - [func WithAutoOptions\(enable bool\) GlobalOption](<#WithAutoOptions>)
  - [func WithMaxRouteParamKeyBytes\(max uint16\) GlobalOption](<#WithMaxRouteParamKeyBytes>)
  - [func WithMaxRouteParams\(max uint16\) GlobalOption](<#WithMaxRouteParams>)
  - [func WithMiddlewareFor\(scope HandlerScope, m ...MiddlewareFunc\) GlobalOption](<#WithMiddlewareFor>)
  - [func WithNoMethod\(enable bool\) GlobalOption](<#WithNoMethod>)
  - [func WithNoMethodHandler\(handler HandlerFunc\) GlobalOption](<#WithNoMethodHandler>)
  - [func WithNoRouteHandler\(handler HandlerFunc\) GlobalOption](<#WithNoRouteHandler>)
  - [func WithOptionsHandler\(handler HandlerFunc\) GlobalOption](<#WithOptionsHandler>)
- [type HandlerFunc](<#HandlerFunc>)
  - [func WrapF\(f http.HandlerFunc\) HandlerFunc](<#WrapF>)
  - [func WrapH\(h http.Handler\) HandlerFunc](<#WrapH>)
- [type HandlerScope](<#HandlerScope>)
- [type Iter](<#Iter>)
  - [func \(it Iter\) All\(\) iter.Seq2\[string, \*Route\]](<#Iter.All>)
  - [func \(it Iter\) Methods\(\) iter.Seq\[string\]](<#Iter.Methods>)
  - [func \(it Iter\) Prefix\(methods iter.Seq\[string\], prefix string\) iter.Seq2\[string, \*Route\]](<#Iter.Prefix>)
  - [func \(it Iter\) Reverse\(methods iter.Seq\[string\], host, path string\) iter.Seq2\[string, \*Route\]](<#Iter.Reverse>)
  - [func \(it Iter\) Routes\(methods iter.Seq\[string\], pattern string\) iter.Seq2\[string, \*Route\]](<#Iter.Routes>)
- [type MiddlewareFunc](<#MiddlewareFunc>)
  - [func CustomRecovery\(handle RecoveryFunc\) MiddlewareFunc](<#CustomRecovery>)
  - [func CustomRecoveryWithLogHandler\(handler slog.Handler, handle RecoveryFunc\) MiddlewareFunc](<#CustomRecoveryWithLogHandler>)
  - [func Logger\(\) MiddlewareFunc](<#Logger>)
  - [func LoggerWithHandler\(handler slog.Handler\) MiddlewareFunc](<#LoggerWithHandler>)
  - [func Recovery\(\) MiddlewareFunc](<#Recovery>)
- [type Option](<#Option>)
  - [func WithClientIPResolver\(resolver ClientIPResolver\) Option](<#WithClientIPResolver>)
  - [func WithIgnoreTrailingSlash\(enable bool\) Option](<#WithIgnoreTrailingSlash>)
  - [func WithMiddleware\(m ...MiddlewareFunc\) Option](<#WithMiddleware>)
  - [func WithRedirectTrailingSlash\(enable bool\) Option](<#WithRedirectTrailingSlash>)
- [type Param](<#Param>)
- [type Params](<#Params>)
  - [func ParamsFromContext\(ctx context.Context\) Params](<#ParamsFromContext>)
  - [func \(p Params\) Get\(name string\) string](<#Params.Get>)
  - [func \(p Params\) Has\(name string\) bool](<#Params.Has>)
- [type RecoveryFunc](<#RecoveryFunc>)
- [type ResponseWriter](<#ResponseWriter>)
- [type Route](<#Route>)
  - [func \(r \*Route\) Annotation\(key any\) any](<#Route.Annotation>)
  - [func \(r \*Route\) ClientIPResolver\(\) ClientIPResolver](<#Route.ClientIPResolver>)
  - [func \(r \*Route\) Handle\(c Context\)](<#Route.Handle>)
  - [func \(r \*Route\) HandleMiddleware\(c Context, \_ ...struct\{\}\)](<#Route.HandleMiddleware>)
  - [func \(r \*Route\) Hostname\(\) string](<#Route.Hostname>)
  - [func \(r \*Route\) IgnoreTrailingSlashEnabled\(\) bool](<#Route.IgnoreTrailingSlashEnabled>)
  - [func \(r \*Route\) ParamsLen\(\) int](<#Route.ParamsLen>)
  - [func \(r \*Route\) Path\(\) string](<#Route.Path>)
  - [func \(r \*Route\) Pattern\(\) string](<#Route.Pattern>)
  - [func \(r \*Route\) RedirectTrailingSlashEnabled\(\) bool](<#Route.RedirectTrailingSlashEnabled>)
- [type RouteConflictError](<#RouteConflictError>)
  - [func \(e \*RouteConflictError\) Error\(\) string](<#RouteConflictError.Error>)
  - [func \(e \*RouteConflictError\) Unwrap\(\) error](<#RouteConflictError.Unwrap>)
- [type RouteOption](<#RouteOption>)
  - [func WithAnnotation\(key, value any\) RouteOption](<#WithAnnotation>)
- [type Router](<#Router>)
  - [func New\(opts ...GlobalOption\) \(\*Router, error\)](<#New>)
  - [func \(fox \*Router\) Delete\(method, pattern string\) \(\*Route, error\)](<#Router.Delete>)
  - [func \(fox \*Router\) Handle\(method, pattern string, handler HandlerFunc, opts ...RouteOption\) \(\*Route, error\)](<#Router.Handle>)
  - [func \(fox \*Router\) HandleNoRoute\(c Context\)](<#Router.HandleNoRoute>)
  - [func \(fox \*Router\) HandleRoute\(method string, route \*Route\) error](<#Router.HandleRoute>)
  - [func \(fox \*Router\) Has\(method, pattern string\) bool](<#Router.Has>)
  - [func \(fox \*Router\) Iter\(\) Iter](<#Router.Iter>)
  - [func \(fox \*Router\) Len\(\) int](<#Router.Len>)
  - [func \(fox \*Router\) Lookup\(w ResponseWriter, r \*http.Request\) \(route \*Route, cc ContextCloser, tsr bool\)](<#Router.Lookup>)
  - [func \(fox \*Router\) MustHandle\(method, pattern string, handler HandlerFunc, opts ...RouteOption\) \*Route](<#Router.MustHandle>)
  - [func \(fox \*Router\) NewRoute\(pattern string, handler HandlerFunc, opts ...RouteOption\) \(\*Route, error\)](<#Router.NewRoute>)
  - [func \(fox \*Router\) Reverse\(method, host, path string\) \(route \*Route, tsr bool\)](<#Router.Reverse>)
  - [func \(fox \*Router\) Route\(method, pattern string\) \*Route](<#Router.Route>)
  - [func \(fox \*Router\) ServeHTTP\(w http.ResponseWriter, r \*http.Request\)](<#Router.ServeHTTP>)
  - [func \(fox \*Router\) Stats\(\) RouterInfo](<#Router.Stats>)
  - [func \(fox \*Router\) Txn\(write bool\) \*Txn](<#Router.Txn>)
  - [func \(fox \*Router\) Update\(method, pattern string, handler HandlerFunc, opts ...RouteOption\) \(\*Route, error\)](<#Router.Update>)
  - [func \(fox \*Router\) UpdateRoute\(method string, route \*Route\) error](<#Router.UpdateRoute>)
  - [func \(fox \*Router\) Updates\(fn func\(txn \*Txn\) error\) error](<#Router.Updates>)
  - [func \(fox \*Router\) View\(fn func\(txn \*Txn\) error\) error](<#Router.View>)
- [type RouterInfo](<#RouterInfo>)
- [type TestContext](<#TestContext>)
  - [func NewTestContextOnly\(w http.ResponseWriter, r \*http.Request, opts ...GlobalOption\) \*TestContext](<#NewTestContextOnly>)
  - [func \(c \*TestContext\) SetParams\(params Params\)](<#TestContext.SetParams>)
  - [func \(c \*TestContext\) SetRoute\(route \*Route\)](<#TestContext.SetRoute>)
  - [func \(c \*TestContext\) SetScope\(scope HandlerScope\)](<#TestContext.SetScope>)
- [type Txn](<#Txn>)
  - [func \(txn \*Txn\) Abort\(\)](<#Txn.Abort>)
  - [func \(txn \*Txn\) Commit\(\)](<#Txn.Commit>)
  - [func \(txn \*Txn\) Delete\(method, pattern string\) \(\*Route, error\)](<#Txn.Delete>)
  - [func \(txn \*Txn\) Handle\(method, pattern string, handler HandlerFunc, opts ...RouteOption\) \(\*Route, error\)](<#Txn.Handle>)
  - [func \(txn \*Txn\) HandleRoute\(method string, route \*Route\) error](<#Txn.HandleRoute>)
  - [func \(txn \*Txn\) Has\(method, pattern string\) bool](<#Txn.Has>)
  - [func \(txn \*Txn\) Iter\(\) Iter](<#Txn.Iter>)
  - [func \(txn \*Txn\) Len\(\) int](<#Txn.Len>)
  - [func \(txn \*Txn\) Lookup\(w ResponseWriter, r \*http.Request\) \(route \*Route, cc ContextCloser, tsr bool\)](<#Txn.Lookup>)
  - [func \(txn \*Txn\) Reverse\(method, host, path string\) \(route \*Route, tsr bool\)](<#Txn.Reverse>)
  - [func \(txn \*Txn\) Route\(method, pattern string\) \*Route](<#Txn.Route>)
  - [func \(txn \*Txn\) Snapshot\(\) \*Txn](<#Txn.Snapshot>)
  - [func \(txn \*Txn\) Truncate\(methods ...string\) error](<#Txn.Truncate>)
  - [func \(txn \*Txn\) Update\(method, pattern string, handler HandlerFunc, opts ...RouteOption\) \(\*Route, error\)](<#Txn.Update>)
  - [func \(txn \*Txn\) UpdateRoute\(method string, route \*Route\) error](<#Txn.UpdateRoute>)


## Constants

<a name="MIMEApplicationJSON"></a>MIME types

```go
const (
    MIMEApplicationJSON                  = "application/json"
    MIMEApplicationJSONCharsetUTF8       = MIMEApplicationJSON + "; " + charsetUTF8
    MIMEApplicationJavaScript            = "application/javascript"
    MIMEApplicationJavaScriptCharsetUTF8 = MIMEApplicationJavaScript + "; " + charsetUTF8
    MIMEApplicationXML                   = "application/xml"
    MIMEApplicationXMLCharsetUTF8        = MIMEApplicationXML + "; " + charsetUTF8
    MIMETextXML                          = "text/xml"
    MIMETextXMLCharsetUTF8               = MIMETextXML + "; " + charsetUTF8
    MIMEApplicationForm                  = "application/x-www-form-urlencoded"
    MIMEApplicationProtobuf              = "application/protobuf"
    MIMEApplicationMsgpack               = "application/msgpack"
    MIMETextHTML                         = "text/html"
    MIMETextHTMLCharsetUTF8              = MIMETextHTML + "; " + charsetUTF8
    MIMETextPlain                        = "text/plain"
    MIMETextPlainCharsetUTF8             = MIMETextPlain + "; " + charsetUTF8
    MIMEMultipartForm                    = "multipart/form-data"
    MIMEOctetStream                      = "application/octet-stream"
)
```

<a name="HeaderAccept"></a>Headers

```go
const (
    HeaderAccept              = "Accept"
    HeaderAcceptEncoding      = "Accept-Encoding"
    HeaderAllow               = "Allow"
    HeaderAuthorization       = "Authorization"
    HeaderProxyAuthorization  = "Proxy-Authorization"
    HeaderContentDisposition  = "Content-Disposition"
    HeaderContentEncoding     = "Content-Encoding"
    HeaderContentLength       = "Content-Length"
    HeaderContentType         = "Content-Type"
    HeaderCookie              = "Cookie"
    HeaderSetCookie           = "Set-Cookie"
    HeaderIfModifiedSince     = "If-Modified-Since"
    HeaderLastModified        = "Last-Modified"
    HeaderLocation            = "Location"
    HeaderRetryAfter          = "Retry-After"
    HeaderUpgrade             = "Upgrade"
    HeaderVary                = "Vary"
    HeaderWWWAuthenticate     = "WWW-Authenticate"
    HeaderXForwardedFor       = "X-Forwarded-For"
    HeaderForwarded           = "Forwarded"
    HeaderXForwardedProto     = "X-Forwarded-Proto"
    HeaderXForwardedProtocol  = "X-Forwarded-Protocol"
    HeaderXForwardedSsl       = "X-Forwarded-Ssl"
    HeaderXUrlScheme          = "X-Url-Scheme"
    HeaderXHTTPMethodOverride = "X-HTTP-Method-Override"
    HeaderXRequestID          = "X-Request-Id"
    HeaderXCorrelationID      = "X-Correlation-Id"
    HeaderXRequestedWith      = "X-Requested-With"
    HeaderServer              = "Server"
    HeaderOrigin              = "Origin"
    HeaderHost                = "Host"
    HeaderCacheControl        = "Cache-Control"
    HeaderConnection          = "Connection"
    HeaderETag                = "ETag"

    // Access control
    HeaderAccessControlRequestMethod    = "Access-Control-Request-Method"
    HeaderAccessControlRequestHeaders   = "Access-Control-Request-Headers"
    HeaderAccessControlAllowOrigin      = "Access-Control-Allow-Origin"
    HeaderAccessControlAllowMethods     = "Access-Control-Allow-Methods"
    HeaderAccessControlAllowHeaders     = "Access-Control-Allow-Headers"
    HeaderAccessControlAllowCredentials = "Access-Control-Allow-Credentials"
    HeaderAccessControlExposeHeaders    = "Access-Control-Expose-Headers"
    HeaderAccessControlMaxAge           = "Access-Control-Max-Age"

    // Security
    HeaderStrictTransportSecurity         = "Strict-Transport-Security"
    HeaderXContentTypeOptions             = "X-Content-Type-Options"
    HeaderXXSSProtection                  = "X-XSS-Protection"
    HeaderXFrameOptions                   = "X-Frame-Options"
    HeaderContentSecurityPolicy           = "Content-Security-Policy"
    HeaderContentSecurityPolicyReportOnly = "Content-Security-Policy-Report-Only"
    // nolint:gosec
    HeaderXCSRFToken     = "X-CSRF-Token"
    HeaderReferrerPolicy = "Referrer-Policy"

    // Platform Header for single IP
    HeaderCFConnectionIP       = "CF-Connecting-IP"
    HeaderTrueClientIP         = "True-Client-IP"
    HeaderFastClientIP         = "Fastly-Client-IP"
    HeaderXAzureClientIP       = "X-Azure-ClientIP"
    HeaderXAzureSocketIP       = "X-Azure-SocketIP"
    HeaderXAppengineRemoteAddr = "X-Appengine-Remote-Addr"
    HeaderFlyClientIP          = "Fly-Client-IP"
    HeaderXRealIP              = "X-Real-Ip"
)
```

<a name="AllHandlers"></a>

```go
const (
    // AllHandlers is a combination of all the above scopes, which can be used to apply middlewares to all types of handlers.
    AllHandlers = RouteHandler | NoRouteHandler | NoMethodHandler | RedirectHandler | OptionsHandler
)
```

## Variables

<a name="ErrRouteNotFound"></a>

```go
var (
    ErrRouteNotFound           = errors.New("route not found")
    ErrRouteExist              = errors.New("route already registered")
    ErrRouteConflict           = errors.New("route conflict")
    ErrInvalidRoute            = errors.New("invalid route")
    ErrDiscardedResponseWriter = errors.New("discarded response writer")
    ErrInvalidRedirectCode     = errors.New("invalid redirect code")
    ErrNoClientIPResolver      = errors.New("no client ip resolver")
    ErrReadOnlyTxn             = errors.New("write on read-only transaction")
    ErrSettledTxn              = errors.New("transaction settled")
    ErrParamKeyTooLarge        = errors.New("parameter key too large")
    ErrTooManyParams           = errors.New("too many params")
    ErrInvalidConfig           = errors.New("invalid config")
)
```

<a name="CleanPath"></a>
## func [CleanPath](<https://github.com/tigerwill90/fox/blob/master/path.go#L26>)

```go
func CleanPath(p string) string
```

CleanPath is the URL version of [path.Clean](<https://pkg.go.dev/path/#Clean>), it returns a canonical URL path for p, eliminating . and .. elements.

The following rules are applied iteratively until no further processing can be done:

1. Replace multiple slashes with a single slash.
2. Eliminate each . path name element \(the current directory\).
3. Eliminate each inner .. path name element \(the parent directory\) along with the non\-.. element that precedes it.
4. Eliminate .. elements that begin a rooted path: that is, replace "/.." by "/" at the beginning of a path.

If the result of this process is an empty string, "/" is returned

<a name="DefaultHandleRecovery"></a>
## func [DefaultHandleRecovery](<https://github.com/tigerwill90/fox/blob/master/recovery.go#L56>)

```go
func DefaultHandleRecovery(c Context, _ any)
```

DefaultHandleRecovery is a default implementation of the [RecoveryFunc](<#RecoveryFunc>). It responds with a status code 500 and writes a generic error message.

<a name="DefaultMethodNotAllowedHandler"></a>
## func [DefaultMethodNotAllowedHandler](<https://github.com/tigerwill90/fox/blob/master/fox.go#L497>)

```go
func DefaultMethodNotAllowedHandler(c Context)
```

DefaultMethodNotAllowedHandler is a simple [HandlerFunc](<#HandlerFunc>) that replies to each request with a “405 Method Not Allowed” reply.

<a name="DefaultNotFoundHandler"></a>
## func [DefaultNotFoundHandler](<https://github.com/tigerwill90/fox/blob/master/fox.go#L491>)

```go
func DefaultNotFoundHandler(c Context)
```

DefaultNotFoundHandler is a simple [HandlerFunc](<#HandlerFunc>) that replies to each request with a “404 page not found” reply.

<a name="DefaultOptionsHandler"></a>
## func [DefaultOptionsHandler](<https://github.com/tigerwill90/fox/blob/master/fox.go#L502>)

```go
func DefaultOptionsHandler(c Context)
```

DefaultOptionsHandler is a simple [HandlerFunc](<#HandlerFunc>) that replies to each request with a "200 OK" reply.

<a name="ErrNotSupported"></a>
## func [ErrNotSupported](<https://github.com/tigerwill90/fox/blob/master/response_writer.go#L332>)

```go
func ErrNotSupported() error
```

ErrNotSupported returns an error that Is http.ErrNotSupported, but is not == to it.

<a name="FixTrailingSlash"></a>
## func [FixTrailingSlash](<https://github.com/tigerwill90/fox/blob/master/path.go#L160>)

```go
func FixTrailingSlash(path string) string
```

FixTrailingSlash ensures a consistent trailing slash handling for a given path. If the path has more than one character and ends with a slash, it removes the trailing slash. Otherwise, it adds a trailing slash to the path.

<a name="NewTestContext"></a>
## func [NewTestContext](<https://github.com/tigerwill90/fox/blob/master/helpers.go#L37>)

```go
func NewTestContext(w http.ResponseWriter, r *http.Request, opts ...GlobalOption) (*Router, *TestContext)
```

NewTestContext returns a new [Router](<#Router>) and its associated [Context](<#Context>), designed only for testing purpose.

<a name="SplitHostPath"></a>
## func [SplitHostPath](<https://github.com/tigerwill90/fox/blob/master/path.go#L170>)

```go
func SplitHostPath(url string) (host, path string)
```

SplitHostPath separates the host and path from a URL string. If url includes a valid numeric port, the port is stripped from the host; otherwise, it remains part of the host. If url is empty or lacks a path, the path defaults to "/". SplitHostPath does not perform host validation.

<a name="ClientIPResolver"></a>
## type [ClientIPResolver](<https://github.com/tigerwill90/fox/blob/master/fox.go#L61-L66>)

ClientIPResolver define a resolver for obtaining the "real" client IP from HTTP requests. The resolver used must be chosen and tuned for your network configuration. This should result in a resolver never returning an error i.e., never failing to find a candidate for the "real" IP. Consequently, getting an error result should be treated as an application error, perhaps even worthy of panicking. Builtin best practices resolver can be found in the github.com/tigerwill90/fox/clientip package.

```go
type ClientIPResolver interface {
    // ClientIP returns the "real" client IP according to the implemented resolver. It returns an error if no valid IP
    // address can be derived. This is typically considered a misconfiguration error, unless the resolver involves
    // obtaining an untrustworthy or optional value.
    ClientIP(c Context) (*net.IPAddr, error)
}
```

<a name="ClientIPResolverFunc"></a>
## type [ClientIPResolverFunc](<https://github.com/tigerwill90/fox/blob/master/fox.go#L70>)

The ClientIPResolverFunc type is an adapter to allow the use of ordinary functions as [ClientIPResolver](<#ClientIPResolver>). If f is a function with the appropriate signature, ClientIPResolverFunc\(f\) is a ClientIPResolverFunc that calls f.

```go
type ClientIPResolverFunc func(c Context) (*net.IPAddr, error)
```

<a name="ClientIPResolverFunc.ClientIP"></a>
### func \(ClientIPResolverFunc\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/fox.go#L73>)

```go
func (f ClientIPResolverFunc) ClientIP(c Context) (*net.IPAddr, error)
```

ClientIP calls f\(c\).

<a name="Context"></a>
## type [Context](<https://github.com/tigerwill90/fox/blob/master/context.go#L31-L98>)

Context represents the context of the current HTTP request. It provides methods to access request data and to write a response. Be aware that the Context API is not thread\-safe and its lifetime should be limited to the duration of the [HandlerFunc](<#HandlerFunc>) execution, as the underlying implementation may be reused a soon as the handler return. \(see \[Context.Clone\] method\).

```go
type Context interface {
    // Request returns the current [http.Request].
    Request() *http.Request
    // SetRequest sets the [*http.Request].
    SetRequest(r *http.Request)
    // Writer method returns a custom [ResponseWriter] implementation.
    Writer() ResponseWriter
    // SetWriter sets the [ResponseWriter].
    SetWriter(w ResponseWriter)
    // RemoteIP parses the IP from [http.Request.RemoteAddr], normalizes it, and returns an IP address. The returned [net.IPAddr]
    // may contain a zone identifier. RemoteIP never returns nil, even if parsing the IP fails.
    RemoteIP() *net.IPAddr
    // ClientIP returns the "real" client IP address based on the configured [ClientIPResolver].
    // The resolver is set using the [WithClientIPResolver] option. There is no sane default, so if no resolver is configured,
    // the method returns [ErrNoClientIPResolver].
    //
    // The resolver used must be chosen and tuned for your network configuration. This should result
    // in a resolver never returning an error -- i.e., never failing to find a candidate for the "real" IP.
    // Consequently, getting an error result should be treated as an application error, perhaps even
    // worthy of panicking.
    //
    // The returned [net.IPAddr] may contain a zone identifier.
    ClientIP() (*net.IPAddr, error)
    // Pattern returns the registered route pattern or an empty string if the handler is called in a scope other than [RouteHandler].
    Pattern() string
    // Route returns the registered [Route] or nil if the handler is called in a scope other than [RouteHandler].
    Route() *Route
    // Params returns a range iterator over the matched wildcard parameters for the current route.
    Params() iter.Seq[Param]
    // Param retrieve a matching wildcard parameter by name.
    Param(name string) string
    // Method returns the request method.
    Method() string
    // Path returns the request URL path.
    Path() string
    // Host returns the request host.
    Host() string
    // QueryParams parses the [http.Request] raw query and returns the corresponding values.
    QueryParams() url.Values
    // QueryParam returns the first query value associated with the given key.
    QueryParam(name string) string
    // SetHeader sets the response header for the given key to the specified value.
    SetHeader(key, value string)
    // AddHeader add the response header for the given key to the specified value.
    AddHeader(key, value string)
    // Header retrieves the value of the request header for the given key.
    Header(key string) string
    // String sends a formatted string with the specified status code.
    String(code int, format string, values ...any) error
    // Blob sends a byte slice with the specified status code and content type.
    Blob(code int, contentType string, buf []byte) error
    // Stream sends data from an [io.Reader] with the specified status code and content type.
    Stream(code int, contentType string, r io.Reader) error
    // Redirect sends an HTTP redirect response with the given status code and URL.
    Redirect(code int, url string) error
    // Clone returns a copy of the [Context] that is safe to use after the [HandlerFunc] returns.
    Clone() Context
    // CloneWith returns a shallow copy of the current [Context], substituting its [ResponseWriter] and [http.Request]
    // with the provided ones. The method is designed for zero allocation during the copy process. The returned
    // [ContextCloser] must be closed once no longer needed. This functionality is particularly beneficial for
    // middlewares that need to wrap their custom [ResponseWriter] while preserving the state of the original [Context].
    CloneWith(w ResponseWriter, r *http.Request) ContextCloser
    // Scope returns the [HandlerScope] associated with the current [Context].
    // This indicates the scope in which the handler is being executed, such as [RouteHandler], [NoRouteHandler], etc.
    Scope() HandlerScope
    // Fox returns the [Router] instance.
    Fox() *Router
}
```

<a name="ContextCloser"></a>
## type [ContextCloser](<https://github.com/tigerwill90/fox/blob/master/context.go#L21-L25>)

ContextCloser extends [Context](<#Context>) for manually created instances, adding a Close method to release resources after use.

```go
type ContextCloser interface {
    Context
    // Close releases the context to be reused later.
    Close()
}
```

<a name="GlobalOption"></a>
## type [GlobalOption](<https://github.com/tigerwill90/fox/blob/master/options.go#L18-L20>)



```go
type GlobalOption interface {
    // contains filtered or unexported methods
}
```

<a name="DefaultOptions"></a>
### func [DefaultOptions](<https://github.com/tigerwill90/fox/blob/master/options.go#L283>)

```go
func DefaultOptions() GlobalOption
```

DefaultOptions configure the router to use the [Recovery](<#Recovery>) middleware for the [RouteHandler](<#RouteHandler>) scope, the [Logger](<#Logger>) middleware for [AllHandlers](<#AllHandlers>) scope and enable automatic OPTIONS response. Note that DefaultOptions push the [Recovery](<#Recovery>) and [Logger](<#Logger>) middleware respectively to the first and second position of the middleware chains.

<a name="WithAutoOptions"></a>
### func [WithAutoOptions](<https://github.com/tigerwill90/fox/blob/master/options.go#L174>)

```go
func WithAutoOptions(enable bool) GlobalOption
```

WithAutoOptions enables automatic response to OPTIONS requests with, by default, a 200 OK status code. Use the [WithOptionsHandler](<#WithOptionsHandler>) option to customize the response. When this option is enabled, the router automatically determines the "Allow" header value based on the methods registered for the given route. Note that custom OPTIONS handler take priority over automatic replies. This option is automatically enabled when providing a custom handler with the option [WithOptionsHandler](<#WithOptionsHandler>).

<a name="WithMaxRouteParamKeyBytes"></a>
### func [WithMaxRouteParamKeyBytes](<https://github.com/tigerwill90/fox/blob/master/options.go#L105>)

```go
func WithMaxRouteParamKeyBytes(max uint16) GlobalOption
```

WithMaxRouteParamKeyBytes set the maximum number of bytes allowed per parameter key in a route. The default max is math.MaxUint16.

<a name="WithMaxRouteParams"></a>
### func [WithMaxRouteParams](<https://github.com/tigerwill90/fox/blob/master/options.go#L96>)

```go
func WithMaxRouteParams(max uint16) GlobalOption
```

WithMaxRouteParams set the maximum number of parameters allowed in a route. The default max is math.MaxUint16.

<a name="WithMiddlewareFor"></a>
### func [WithMiddlewareFor](<https://github.com/tigerwill90/fox/blob/master/options.go#L146>)

```go
func WithMiddlewareFor(scope HandlerScope, m ...MiddlewareFunc) GlobalOption
```

WithMiddlewareFor attaches middleware to the router for a specified scope. Middlewares provided will be chained in the order they were added. The scope parameter determines which types of handlers the middleware will be applied to. Possible scopes include [RouteHandler](<#RouteHandler>) \(regular routes\), [NoRouteHandler](<#RouteHandler>), [NoMethodHandler](<#RouteHandler>), [RedirectHandler](<#RouteHandler>), [OptionsHandler](<#RouteHandler>), and any combination of these. Use this option when you need fine\-grained control over where the middleware is applied.

<a name="WithNoMethod"></a>
### func [WithNoMethod](<https://github.com/tigerwill90/fox/blob/master/options.go#L162>)

```go
func WithNoMethod(enable bool) GlobalOption
```

WithNoMethod enable to returns 405 Method Not Allowed instead of 404 Not Found when the route exist for another http verb. The "Allow" header it automatically set before calling the handler. Note that this option is automatically enabled when providing a custom handler with the option [WithNoMethodHandler](<#WithNoMethodHandler>).

<a name="WithNoMethodHandler"></a>
### func [WithNoMethodHandler](<https://github.com/tigerwill90/fox/blob/master/options.go#L69>)

```go
func WithNoMethodHandler(handler HandlerFunc) GlobalOption
```

WithNoMethodHandler register an [HandlerFunc](<#HandlerFunc>) which is called when the request cannot be routed, but the same route exist for other methods. The "Allow" header it automatically set before calling the handler. By default, the [DefaultMethodNotAllowedHandler](<#DefaultMethodNotAllowedHandler>) is used. Note that this option automatically enable [WithNoMethod](<#WithNoMethod>).

<a name="WithNoRouteHandler"></a>
### func [WithNoRouteHandler](<https://github.com/tigerwill90/fox/blob/master/options.go#L55>)

```go
func WithNoRouteHandler(handler HandlerFunc) GlobalOption
```

WithNoRouteHandler register an [HandlerFunc](<#HandlerFunc>) which is called when no matching route is found. By default, the [DefaultNotFoundHandler](<#DefaultNotFoundHandler>) is used.

<a name="WithOptionsHandler"></a>
### func [WithOptionsHandler](<https://github.com/tigerwill90/fox/blob/master/options.go#L84>)

```go
func WithOptionsHandler(handler HandlerFunc) GlobalOption
```

WithOptionsHandler register an [HandlerFunc](<#HandlerFunc>) which is called on automatic OPTIONS requests. By default, the router respond with a 200 OK status code. The "Allow" header it automatically set before calling the handler. Note that custom OPTIONS handler take priority over automatic replies. By default, [DefaultOptionsHandler](<#DefaultOptionsHandler>) is used. Note that this option automatically enable [WithAutoOptions](<#WithAutoOptions>).

<a name="HandlerFunc"></a>
## type [HandlerFunc](<https://github.com/tigerwill90/fox/blob/master/fox.go#L48>)

HandlerFunc is a function type that responds to an HTTP request. It enforces the same contract as \[http.Handler\] but provides additional feature like matched wildcard route segments via the [Context](<#Context>) type. The [Context](<#Context>) is freed once the HandlerFunc returns and may be reused later to save resources. If you need to hold the context longer, you have to copy it \(see \[Context.Clone\] method\).

Similar to \[http.Handler\], to abort a HandlerFunc so the client sees an interrupted response, panic with the value \[http.ErrAbortHandler\].

HandlerFunc functions should be thread\-safe, as they will be called concurrently.

```go
type HandlerFunc func(c Context)
```

<a name="WrapF"></a>
### func [WrapF](<https://github.com/tigerwill90/fox/blob/master/context.go#L419>)

```go
func WrapF(f http.HandlerFunc) HandlerFunc
```

WrapF is an adapter for wrapping \[http.HandlerFunc\] and returns a [HandlerFunc](<#HandlerFunc>) function. The route parameters are being accessed by the wrapped handler through the context.

<a name="WrapH"></a>
### func [WrapH](<https://github.com/tigerwill90/fox/blob/master/context.go#L434>)

```go
func WrapH(h http.Handler) HandlerFunc
```

WrapH is an adapter for wrapping http.Handler and returns a HandlerFunc function. The route parameters are being accessed by the wrapped handler through the context.

<a name="HandlerScope"></a>
## type [HandlerScope](<https://github.com/tigerwill90/fox/blob/master/fox.go#L79>)

HandlerScope represents different scopes where a handler may be called. It also allows for fine\-grained control over where middleware is applied.

```go
type HandlerScope uint8
```

<a name="RouteHandler"></a>

```go
const (
    // RouteHandler scope applies to regular routes registered in the router.
    RouteHandler HandlerScope = 1 << (8 - 1 - iota)
    // NoRouteHandler scope applies to the NoRoute handler, which is invoked when no route matches the request.
    NoRouteHandler
    // NoMethodHandler scope applies to the NoMethod handler, which is invoked when a route exists, but the method is not allowed.
    NoMethodHandler
    // RedirectHandler scope applies to the internal redirect handler, used for handling requests with trailing slashes.
    RedirectHandler
    // OptionsHandler scope applies to the automatic OPTIONS handler, which handles pre-flight or cross-origin requests.
    OptionsHandler
)
```

<a name="Iter"></a>
## type [Iter](<https://github.com/tigerwill90/fox/blob/master/iter.go#L62-L66>)

Iter provide a set of range iterators for traversing registered methods and routes. Iter capture a point\-in\-time snapshot of the routing tree. Therefore, all iterators returned by Iter will not observe subsequent write on the router or on the transaction from which the Iter is created.

```go
type Iter struct {
    // contains filtered or unexported fields
}
```

<a name="Iter.All"></a>
### func \(Iter\) [All](<https://github.com/tigerwill90/fox/blob/master/iter.go#L183>)

```go
func (it Iter) All() iter.Seq2[string, *Route]
```

All returns a range iterator over all routes registered in the routing tree. The iterator reflect a snapshot of the routing tree at the time [Iter](<#Iter>) is created. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing.

<details><summary>Example</summary>
<p>



```go
f, _ := New()
it := f.Iter()
for method, route := range it.All() {
	fmt.Println(method, route.Pattern())
}
```

</p>
</details>

<a name="Iter.Methods"></a>
### func \(Iter\) [Methods](<https://github.com/tigerwill90/fox/blob/master/iter.go#L71>)

```go
func (it Iter) Methods() iter.Seq[string]
```

Methods returns a range iterator over all HTTP methods registered in the routing tree. The iterator reflect a snapshot of the routing tree at the time [Iter](<#Iter>) is created. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing.

<details><summary>Example</summary>
<p>



```go
f, _ := New()
it := f.Iter()
for method := range it.Methods() {
	fmt.Println(method)
}
```

</p>
</details>

<a name="Iter.Prefix"></a>
### func \(Iter\) [Prefix](<https://github.com/tigerwill90/fox/blob/master/iter.go#L131>)

```go
func (it Iter) Prefix(methods iter.Seq[string], prefix string) iter.Seq2[string, *Route]
```

Prefix returns a range iterator over all routes in the routing tree that match a given prefix and HTTP methods. The iterator reflect a snapshot of the routing tree at the time [Iter](<#Iter>) is created. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing.

<details><summary>Example</summary>
<p>



```go
f, _ := New()
it := f.Iter()
for method, route := range it.Prefix(slices.Values([]string{"GET", "POST"}), "/foo") {
	fmt.Println(method, route.Pattern())
}
```

</p>
</details>

<a name="Iter.Reverse"></a>
### func \(Iter\) [Reverse](<https://github.com/tigerwill90/fox/blob/master/iter.go#L112>)

```go
func (it Iter) Reverse(methods iter.Seq[string], host, path string) iter.Seq2[string, *Route]
```

Reverse returns a range iterator over all routes registered in the routing tree that match the given host and path for the provided HTTP methods. Unlike [Iter.Routes](<#Iter.Routes>), which matches an exact route, Reverse is used to match an url \(e.g., a path from an incoming request\) to a registered routes in the tree. The iterator reflect a snapshot of the routing tree at the time [Iter](<#Iter>) is created.

If [WithIgnoreTrailingSlash](<#WithIgnoreTrailingSlash>) or [WithRedirectTrailingSlash](<#WithRedirectTrailingSlash>) option is enabled on a route, Reverse will match it regardless of whether a trailing slash is present. If the path is empty, a default slash is automatically added.

This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing.

<details><summary>Example</summary>
<p>



```go
f, _ := New()
it := f.Iter()
for method, route := range it.Reverse(slices.Values([]string{"GET", "POST"}), "exemple.com", "/foo") {
	fmt.Println(method, route.Pattern())
}
```

</p>
</details>

<a name="Iter.Routes"></a>
### func \(Iter\) [Routes](<https://github.com/tigerwill90/fox/blob/master/iter.go#L86>)

```go
func (it Iter) Routes(methods iter.Seq[string], pattern string) iter.Seq2[string, *Route]
```

Routes returns a range iterator over all registered routes in the routing tree that exactly match the provided route pattern for the given HTTP methods. The iterator reflect a snapshot of the routing tree at the time [Iter](<#Iter>) is created. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing.

<details><summary>Example</summary>
<p>



```go
f, _ := New()
it := f.Iter()
for method, route := range it.Routes(slices.Values([]string{"GET", "POST"}), "/hello/{name}") {
	fmt.Println(method, route.Pattern())
}
```

</p>
</details>

<a name="MiddlewareFunc"></a>
## type [MiddlewareFunc](<https://github.com/tigerwill90/fox/blob/master/fox.go#L54>)

MiddlewareFunc is a function type for implementing [HandlerFunc](<#HandlerFunc>) middleware. The returned [HandlerFunc](<#HandlerFunc>) usually wraps the input [HandlerFunc](<#HandlerFunc>), allowing you to perform operations before and/or after the wrapped [HandlerFunc](<#HandlerFunc>) is executed. MiddlewareFunc functions should be thread\-safe, as they will be called concurrently.

```go
type MiddlewareFunc func(next HandlerFunc) HandlerFunc
```

<a name="CustomRecovery"></a>
### func [CustomRecovery](<https://github.com/tigerwill90/fox/blob/master/recovery.go#L44>)

```go
func CustomRecovery(handle RecoveryFunc) MiddlewareFunc
```

CustomRecovery returns a middleware that recovers from any panics, logs the error, request details, and stack trace, and then calls the provided handle function to handle the recovery.

<a name="CustomRecoveryWithLogHandler"></a>
### func [CustomRecoveryWithLogHandler](<https://github.com/tigerwill90/fox/blob/master/recovery.go#L32>)

```go
func CustomRecoveryWithLogHandler(handler slog.Handler, handle RecoveryFunc) MiddlewareFunc
```

CustomRecoveryWithLogHandler returns a middleware for a given \[slog.Handler\] that recovers from any panics, logs the error, request details, and stack trace, and then calls the provided handle function to handle the recovery.

<a name="Logger"></a>
### func [Logger](<https://github.com/tigerwill90/fox/blob/master/logger.go#L71>)

```go
func Logger() MiddlewareFunc
```

Logger returns a middleware that logs request information to [os.Stdout](<https://pkg.go.dev/os/#Stdout>) or [os.Stderr](<https://pkg.go.dev/os/#Stderr>) \(for ERROR level\). It logs details such as the remote or client IP, HTTP method, request path, status code and latency.

<a name="LoggerWithHandler"></a>
### func [LoggerWithHandler](<https://github.com/tigerwill90/fox/blob/master/logger.go#L16>)

```go
func LoggerWithHandler(handler slog.Handler) MiddlewareFunc
```

LoggerWithHandler returns a middleware that logs request information using the provided \[slog.Handler\]. It logs details such as the remote or client IP, HTTP method, request path, status code and latency.

<a name="Recovery"></a>
### func [Recovery](<https://github.com/tigerwill90/fox/blob/master/recovery.go#L50>)

```go
func Recovery() MiddlewareFunc
```

Recovery returns a middleware that recovers from any panics, logs the error, request details, and stack trace, and writes a 500 status code response if a panic occurs.

<a name="Option"></a>
## type [Option](<https://github.com/tigerwill90/fox/blob/master/options.go#L13-L16>)



```go
type Option interface {
    GlobalOption
    RouteOption
}
```

<a name="WithClientIPResolver"></a>
### func [WithClientIPResolver](<https://github.com/tigerwill90/fox/blob/master/options.go#L248>)

```go
func WithClientIPResolver(resolver ClientIPResolver) Option
```

WithClientIPResolver sets the resolver for obtaining the "real" client IP address from HTTP requests. This resolver is used by the \[Context.ClientIP\] method. The resolver must be chosen and tuned for your network configuration to ensure it never returns an error \-\- i.e., never fails to find a candidate for the "real" IP. Consequently, getting an error result should be treated as an application error, perhaps even worthy of panicking. There is no sane default, so if no resolver is configured, \[Context.ClientIP\] returns [ErrNoClientIPResolver](<#ErrRouteNotFound>).

This option can be applied on a per\-route basis or globally:

- If applied globally, it affects all routes by default.
- If applied to a specific route, it will override the global setting for that route.
- Setting the resolver to nil is equivalent to no resolver configured.

<a name="WithIgnoreTrailingSlash"></a>
### func [WithIgnoreTrailingSlash](<https://github.com/tigerwill90/fox/blob/master/options.go#L220>)

```go
func WithIgnoreTrailingSlash(enable bool) Option
```

WithIgnoreTrailingSlash allows the router to match routes regardless of whether a trailing slash is present or not. E.g. /foo/bar/ and /foo/bar would both match the same handler. This option prevents the router from issuing a redirect and instead matches the request directly.

This option can be applied on a per\-route basis or globally:

- If applied globally, it affects all routes by default.
- If applied to a specific route, it will override the global setting for that route.

Note that this option is mutually exclusive with [WithRedirectTrailingSlash](<#WithRedirectTrailingSlash>), and if enabled will automatically deactivate [WithRedirectTrailingSlash](<#WithRedirectTrailingSlash>).

<a name="WithMiddleware"></a>
### func [WithMiddleware](<https://github.com/tigerwill90/fox/blob/master/options.go#L119>)

```go
func WithMiddleware(m ...MiddlewareFunc) Option
```

WithMiddleware attaches middleware to the router or to a specific route. The middlewares are executed in the order they are added. When applied globally, the middleware affects all handlers, including special handlers such as NotFound, MethodNotAllowed, AutoOption, and the internal redirect handler.

This option can be applied on a per\-route basis or globally: \- If applied globally, the middleware will be applied to all routes and handlers by default. \- If applied to a specific route, the middleware will only apply to that route and will be chained after any global middleware.

<details><summary>Example</summary>
<p>

This example demonstrates how to register a global middleware that will be applied to all routes.

```go
// Define a custom middleware to measure the time taken for request processing and
// log the URL, route, time elapsed, and status code.
metrics := func(next HandlerFunc) HandlerFunc {
	return func(c Context) {
		start := time.Now()
		next(c)
		log.Printf(
			"url=%s; route=%s; time=%d; status=%d",
			c.Request().URL,
			c.Pattern(),
			time.Since(start),
			c.Writer().Status(),
		)
	}
}

f, _ := New(WithMiddleware(metrics))

f.MustHandle(http.MethodGet, "/hello/{name}", func(c Context) {
	_ = c.String(200, "Hello %s\n", c.Param("name"))
})
```

</p>
</details>

<a name="WithRedirectTrailingSlash"></a>
### func [WithRedirectTrailingSlash](<https://github.com/tigerwill90/fox/blob/master/options.go#L192>)

```go
func WithRedirectTrailingSlash(enable bool) Option
```

WithRedirectTrailingSlash enable automatic redirection fallback when the current request does not match but another handler is found with/without an additional trailing slash. E.g. /foo/bar/ request does not match but /foo/bar would match. The client is redirected with a http status code 301 for GET requests and 308 for all other methods.

This option can be applied on a per\-route basis or globally:

- If applied globally, it affects all routes by default.
- If applied to a specific route, it will override the global setting for that route.

Note that this option is mutually exclusive with [WithIgnoreTrailingSlash](<#WithIgnoreTrailingSlash>), and if enabled will automatically deactivate [WithIgnoreTrailingSlash](<#WithIgnoreTrailingSlash>).

<a name="Param"></a>
## type [Param](<https://github.com/tigerwill90/fox/blob/master/params.go#L14-L17>)



```go
type Param struct {
    Key   string
    Value string
}
```

<a name="Params"></a>
## type [Params](<https://github.com/tigerwill90/fox/blob/master/params.go#L19>)



```go
type Params []Param
```

<a name="ParamsFromContext"></a>
### func [ParamsFromContext](<https://github.com/tigerwill90/fox/blob/master/params.go#L51>)

```go
func ParamsFromContext(ctx context.Context) Params
```

ParamsFromContext is a helper to retrieve params from context.Context when a http.Handler is registered using WrapF or WrapH.

<a name="Params.Get"></a>
### func \(Params\) [Get](<https://github.com/tigerwill90/fox/blob/master/params.go#L22>)

```go
func (p Params) Get(name string) string
```

Get the matching wildcard segment by name.

<a name="Params.Has"></a>
### func \(Params\) [Has](<https://github.com/tigerwill90/fox/blob/master/params.go#L32>)

```go
func (p Params) Has(name string) bool
```

Has checks whether the parameter exists by name.

<a name="RecoveryFunc"></a>
## type [RecoveryFunc](<https://github.com/tigerwill90/fox/blob/master/recovery.go#L28>)

RecoveryFunc is a function type that defines how to handle panics that occur during the handling of an HTTP request.

```go
type RecoveryFunc func(c Context, err any)
```

<a name="ResponseWriter"></a>
## type [ResponseWriter](<https://github.com/tigerwill90/fox/blob/master/response_writer.go#L38-L79>)

ResponseWriter extends \[http.ResponseWriter\] and provides methods to retrieve the recorded status code, written state, and response size.

```go
type ResponseWriter interface {
    http.ResponseWriter
    io.StringWriter
    io.ReaderFrom
    // Status recorded after Write and WriteHeader.
    Status() int
    // Written returns true if the response has been written.
    Written() bool
    // Size returns the size of the written response.
    Size() int
    // FlushError flushes buffered data to the client. If flush is not supported, FlushError returns an error
    // matching [http.ErrNotSupported]. See [http.Flusher] for more details.
    FlushError() error
    // Hijack lets the caller take over the connection. If hijacking the connection is not supported, Hijack returns
    // an error matching [http.ErrNotSupported]. See [http.Hijacker] for more details.
    Hijack() (net.Conn, *bufio.ReadWriter, error)
    // Push initiates an HTTP/2 server push. Push returns [http.ErrNotSupported] if the client has disabled push or if push
    // is not supported on the underlying connection. See [http.Pusher] for more details.
    Push(target string, opts *http.PushOptions) error
    // SetReadDeadline sets the deadline for reading the entire request, including the body. Reads from the request
    // body after the deadline has been exceeded will return an error. A zero value means no deadline. Setting the read
    // deadline after it has been exceeded will not extend it. If SetReadDeadline is not supported, it returns
    // an error matching [http.ErrNotSupported].
    SetReadDeadline(deadline time.Time) error
    // SetWriteDeadline sets the deadline for writing the response. Writes to the response body after the deadline has
    // been exceeded will not block, but may succeed if the data has been buffered. A zero value means no deadline.
    // Setting the write deadline after it has been exceeded will not extend it. If SetWriteDeadline is not supported,
    // it returns an error matching [http.ErrNotSupported].
    SetWriteDeadline(deadline time.Time) error
    // EnableFullDuplex indicates that the request handler will interleave reads from [http.Request.Body]
    // with writes to the [ResponseWriter].
    //
    // For HTTP/1 requests, the Go HTTP server by default consumes any unread portion of
    // the request body before beginning to write the response, preventing handlers from
    // concurrently reading from the request and writing the response.
    // Calling EnableFullDuplex disables this behavior and permits handlers to continue to read
    // from the request while concurrently writing the response.
    //
    // For HTTP/2 requests, the Go HTTP server always permits concurrent reads and responses.
    // If EnableFullDuplex is not supported, it returns an error matching [http.ErrNotSupported].
    EnableFullDuplex() error
}
```

<a name="Route"></a>
## type [Route](<https://github.com/tigerwill90/fox/blob/master/route.go#L4-L16>)

Route represents an immutable HTTP route with associated handlers and settings.

```go
type Route struct {
    // contains filtered or unexported fields
}
```

<a name="Route.Annotation"></a>
### func \(\*Route\) [Annotation](<https://github.com/tigerwill90/fox/blob/master/route.go#L47>)

```go
func (r *Route) Annotation(key any) any
```

Annotation returns the value associated with this [Route](<#Route>) for key, or nil if no value is associated with key. Successive calls to Annotation with the same key returns the same result.

<a name="Route.ClientIPResolver"></a>
### func \(\*Route\) [ClientIPResolver](<https://github.com/tigerwill90/fox/blob/master/route.go#L64>)

```go
func (r *Route) ClientIPResolver() ClientIPResolver
```

ClientIPResolver returns the [ClientIPResolver](<#ClientIPResolver>) configured for the route, if any.

<a name="Route.Handle"></a>
### func \(\*Route\) [Handle](<https://github.com/tigerwill90/fox/blob/master/route.go#L19>)

```go
func (r *Route) Handle(c Context)
```

Handle calls the handler with the provided [Context](<#Context>). See also [Route.HandleMiddleware](<#Route.HandleMiddleware>).

<a name="Route.HandleMiddleware"></a>
### func \(\*Route\) [HandleMiddleware](<https://github.com/tigerwill90/fox/blob/master/route.go#L24>)

```go
func (r *Route) HandleMiddleware(c Context, _ ...struct{})
```

HandleMiddleware calls the handler with route\-specific middleware applied, using the provided [Context](<#Context>).

<a name="Route.Hostname"></a>
### func \(\*Route\) [Hostname](<https://github.com/tigerwill90/fox/blob/master/route.go#L36>)

```go
func (r *Route) Hostname() string
```

Hostname returns the hostname part of the registered pattern if any.

<a name="Route.IgnoreTrailingSlashEnabled"></a>
### func \(\*Route\) [IgnoreTrailingSlashEnabled](<https://github.com/tigerwill90/fox/blob/master/route.go#L59>)

```go
func (r *Route) IgnoreTrailingSlashEnabled() bool
```

IgnoreTrailingSlashEnabled returns whether the route is configured to ignore trailing slashes in requests when matching routes.

<a name="Route.ParamsLen"></a>
### func \(\*Route\) [ParamsLen](<https://github.com/tigerwill90/fox/blob/master/route.go#L72>)

```go
func (r *Route) ParamsLen() int
```

ParamsLen returns the number of wildcard parameter for the route.

<a name="Route.Path"></a>
### func \(\*Route\) [Path](<https://github.com/tigerwill90/fox/blob/master/route.go#L41>)

```go
func (r *Route) Path() string
```

Path returns the path part of the registered pattern.

<a name="Route.Pattern"></a>
### func \(\*Route\) [Pattern](<https://github.com/tigerwill90/fox/blob/master/route.go#L31>)

```go
func (r *Route) Pattern() string
```

Pattern returns the registered route pattern.

<a name="Route.RedirectTrailingSlashEnabled"></a>
### func \(\*Route\) [RedirectTrailingSlashEnabled](<https://github.com/tigerwill90/fox/blob/master/route.go#L53>)

```go
func (r *Route) RedirectTrailingSlashEnabled() bool
```

RedirectTrailingSlashEnabled returns whether the route is configured to automatically redirect requests that include or omit a trailing slash.

<a name="RouteConflictError"></a>
## type [RouteConflictError](<https://github.com/tigerwill90/fox/blob/master/error.go#L31-L37>)

RouteConflictError is a custom error type used to represent conflicts when registering or updating routes in the router. It holds information about the conflicting method, path, and the matched routes that caused the conflict.

```go
type RouteConflictError struct {
    Method  string
    Path    string
    Matched []string
    // contains filtered or unexported fields
}
```

<a name="RouteConflictError.Error"></a>
### func \(\*RouteConflictError\) [Error](<https://github.com/tigerwill90/fox/blob/master/error.go#L49>)

```go
func (e *RouteConflictError) Error() string
```

Error returns a formatted error message for the [RouteConflictError](<#RouteConflictError>).

<a name="RouteConflictError.Unwrap"></a>
### func \(\*RouteConflictError\) [Unwrap](<https://github.com/tigerwill90/fox/blob/master/error.go#L66>)

```go
func (e *RouteConflictError) Unwrap() error
```

Unwrap returns the sentinel value [ErrRouteConflict](<#ErrRouteNotFound>).

<a name="RouteOption"></a>
## type [RouteOption](<https://github.com/tigerwill90/fox/blob/master/options.go#L22-L24>)



```go
type RouteOption interface {
    // contains filtered or unexported methods
}
```

<a name="WithAnnotation"></a>
### func [WithAnnotation](<https://github.com/tigerwill90/fox/blob/master/options.go#L267>)

```go
func WithAnnotation(key, value any) RouteOption
```

WithAnnotation attach arbitrary metadata to routes. Annotations are key\-value pairs that allow middleware, handler or any other components to modify behavior based on the attached metadata. Unlike context\-based metadata, which is tied to the request lifetime, annotations are bound to the route's lifetime and remain static across all requests for that route. The provided key must be comparable and should not be of type string or any other built\-in type to avoid collisions between packages that use route annotation.

<a name="Router"></a>
## type [Router](<https://github.com/tigerwill90/fox/blob/master/fox.go#L101-L117>)

Router is a lightweight high performance HTTP request router that support mutation on its routing tree while handling request concurrently.

```go
type Router struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func [New](<https://github.com/tigerwill90/fox/blob/master/fox.go#L139>)

```go
func New(opts ...GlobalOption) (*Router, error)
```

New returns a ready to use instance of Fox router.

<details><summary>Example</summary>
<p>

This example demonstrates how to create a simple router using the default options, which include the Recovery and Logger middleware.

```go
// Create a new router with default options, which include the Recovery and Logger middleware
r, _ := New(DefaultOptions())

// Define a route with the path "/hello/{name}", and set a simple handler that greets the
// user by their name.
r.MustHandle(http.MethodGet, "/hello/{name}", func(c Context) {
	_ = c.String(200, "Hello %s\n", c.Param("name"))
})

// Start the HTTP server using fox router and listen on port 8080
log.Fatalln(http.ListenAndServe(":8080", r))
```

</p>
</details>

<a name="Router.Delete"></a>
### func \(\*Router\) [Delete](<https://github.com/tigerwill90/fox/blob/master/fox.go#L257>)

```go
func (fox *Router) Delete(method, pattern string) (*Route, error)
```

Delete deletes an existing route for the given method and pattern. On success, it returns the deleted [Route](<#Route>).

- [ErrRouteNotFound](<#ErrRouteNotFound>): If the route does not exist.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method or pattern is invalid.

It's safe to delete a handler while the router is serving requests. This function is safe for concurrent use by multiple goroutine.

<a name="Router.Handle"></a>
### func \(\*Router\) [Handle](<https://github.com/tigerwill90/fox/blob/master/fox.go#L183>)

```go
func (fox *Router) Handle(method, pattern string, handler HandlerFunc, opts ...RouteOption) (*Route, error)
```

Handle registers a new route for the given method and pattern. On success, it returns the newly registered [Route](<#Route>). If an error occurs, it returns one of the following:

- [ErrRouteExist](<#ErrRouteNotFound>): If the route is already registered.
- [ErrRouteConflict](<#ErrRouteNotFound>): If the route conflicts with another.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method or pattern is invalid.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.

It's safe to add a new handler while the router is serving requests. This function is safe for concurrent use by multiple goroutine. To override an existing handler, use [Router.Update](<#Router.Update>).

<a name="Router.HandleNoRoute"></a>
### func \(\*Router\) [HandleNoRoute](<https://github.com/tigerwill90/fox/blob/master/fox.go#L366>)

```go
func (fox *Router) HandleNoRoute(c Context)
```

HandleNoRoute calls the no route handler with the provided [Context](<#Context>).

<a name="Router.HandleRoute"></a>
### func \(\*Router\) [HandleRoute](<https://github.com/tigerwill90/fox/blob/master/fox.go#L202>)

```go
func (fox *Router) HandleRoute(method string, route *Route) error
```

HandleRoute registers a new [Route](<#Route>) for the given method. If an error occurs, it returns one of the following:

- [ErrRouteExist](<#ErrRouteNotFound>): If the route is already registered.
- [ErrRouteConflict](<#ErrRouteNotFound>): If the route conflicts with another.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method is invalid or the route is missing.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.

It's safe to add a new route while the router is serving requests. This function is safe for concurrent use by multiple goroutine. To override an existing route, use [Router.UpdateRoute](<#Router.UpdateRoute>).

<a name="Router.Has"></a>
### func \(\*Router\) [Has](<https://github.com/tigerwill90/fox/blob/master/fox.go#L270>)

```go
func (fox *Router) Has(method, pattern string) bool
```

Has allows to check if the given method and route pattern exactly match a registered route. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing. See also [Router.Route](<#Router.Route>) as an alternative.

<details><summary>Example</summary>
<p>

This example demonstrates how to check if a given route is registered in the tree.

```go
f, _ := New()
f.MustHandle(http.MethodGet, "/hello/{name}", emptyHandler)
exist := f.Has(http.MethodGet, "/hello/{name}")
fmt.Println(exist) // true
```

</p>
</details>

<a name="Router.Iter"></a>
### func \(\*Router\) [Iter](<https://github.com/tigerwill90/fox/blob/master/fox.go#L380>)

```go
func (fox *Router) Iter() Iter
```

Iter returns a collection of range iterators for traversing registered methods and routes. It creates a point\-in\-time snapshot of the routing tree. Therefore, all iterators returned by Iter will not observe subsequent write on the router. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing.

<a name="Router.Len"></a>
### func \(\*Router\) [Len](<https://github.com/tigerwill90/fox/blob/master/fox.go#L371>)

```go
func (fox *Router) Len() int
```

Len returns the number of registered route.

<a name="Router.Lookup"></a>
### func \(\*Router\) [Lookup](<https://github.com/tigerwill90/fox/blob/master/fox.go#L313>)

```go
func (fox *Router) Lookup(w ResponseWriter, r *http.Request) (route *Route, cc ContextCloser, tsr bool)
```

Lookup performs a manual route lookup for a given \[http.Request\], returning the matched [Route](<#Route>) along with a [ContextCloser](<#ContextCloser>), and a boolean indicating if the route was matched by adding or removing a trailing slash \(trailing slash action recommended\). If there is a direct match or a tsr is possible, Lookup always return a [Route](<#Route>) and a [ContextCloser](<#ContextCloser>). The [ContextCloser](<#ContextCloser>) should always be closed if non\-nil. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing. See also [Router.Reverse](<#Router.Reverse>) as an alternative.

<details><summary>Example</summary>
<p>

This example demonstrates how to create a custom middleware that cleans the request path and performs a manual lookup on the tree. If the cleaned path matches a registered route, the client is redirected to the valid path.

```go
redirectFixedPath := MiddlewareFunc(func(next HandlerFunc) HandlerFunc {
	return func(c Context) {
		req := c.Request()
		target := req.URL.Path
		cleanedPath := CleanPath(target)

		// Nothing to clean, call next handler.
		if cleanedPath == target {
			next(c)
			return
		}

		req.URL.Path = cleanedPath
		route, cc, tsr := c.Fox().Lookup(c.Writer(), req)
		if route != nil {
			defer cc.Close()

			code := http.StatusMovedPermanently
			if req.Method != http.MethodGet {
				code = http.StatusPermanentRedirect
			}

			// Redirect the client if direct match or indirect match.
			if !tsr || route.IgnoreTrailingSlashEnabled() {
				if err := c.Redirect(code, cleanedPath); err != nil {
					// Only if not in the range 300..308, so not possible here!
					panic(err)
				}
				return
			}

			// Add or remove an extra trailing slash and redirect the client.
			if route.RedirectTrailingSlashEnabled() {
				if err := c.Redirect(code, FixTrailingSlash(cleanedPath)); err != nil {
					// Only if not in the range 300..308, so not possible here
					panic(err)
				}
				return
			}
		}

		// rollback to the original path before calling the
		// next handler or middleware.
		req.URL.Path = target
		next(c)
	}
})

f, _ := New(
	// Register the middleware for the NoRouteHandler scope.
	WithMiddlewareFor(NoRouteHandler|NoMethodHandler, redirectFixedPath),
)

f.MustHandle(http.MethodGet, "/hello/{name}", func(c Context) {
	_ = c.String(200, "Hello %s\n", c.Param("name"))
})
```

</p>
</details>

<a name="Router.MustHandle"></a>
### func \(\*Router\) [MustHandle](<https://github.com/tigerwill90/fox/blob/master/fox.go#L166>)

```go
func (fox *Router) MustHandle(method, pattern string, handler HandlerFunc, opts ...RouteOption) *Route
```

MustHandle registers a new route for the given method and pattern. On success, it returns the newly registered [Route](<#Route>). This function is a convenience wrapper for the [Router.Handle](<#Router.Handle>) function and panics on error.

<a name="Router.NewRoute"></a>
### func \(\*Router\) [NewRoute](<https://github.com/tigerwill90/fox/blob/master/fox.go#L338>)

```go
func (fox *Router) NewRoute(pattern string, handler HandlerFunc, opts ...RouteOption) (*Route, error)
```

NewRoute create a new [Route](<#Route>), configured with the provided options. If an error occurs, it returns one of the following:

- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method or pattern is invalid.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.

<a name="Router.Reverse"></a>
### func \(\*Router\) [Reverse](<https://github.com/tigerwill90/fox/blob/master/fox.go#L296>)

```go
func (fox *Router) Reverse(method, host, path string) (route *Route, tsr bool)
```

Reverse perform a reverse lookup for the given method, host and path and return the matching registered [Route](<#Route>) \(if any\) along with a boolean indicating if the route was matched by adding or removing a trailing slash \(trailing slash action recommended\). If the path is empty, a default slash is automatically added. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing. See also [Router.Lookup](<#Router.Lookup>) as an alternative.

<details><summary>Example</summary>
<p>

This example demonstrates how to do a reverse lookup on the tree.

```go
f, _ := New()
f.MustHandle(http.MethodGet, "exemple.com/hello/{name}", emptyHandler)
route, _ := f.Reverse(http.MethodGet, "exemple.com", "/hello/fox")
fmt.Println(route.Pattern()) // /hello/{name}
```

</p>
</details>

<a name="Router.Route"></a>
### func \(\*Router\) [Route](<https://github.com/tigerwill90/fox/blob/master/fox.go#L277>)

```go
func (fox *Router) Route(method, pattern string) *Route
```

Route performs a lookup for a registered route matching the given method and route pattern. It returns the [Route](<#Route>) if a match is found or nil otherwise. This function is safe for concurrent use by multiple goroutine and while mutation on route are ongoing. See also [Router.Has](<#Router.Has>) as an alternative.

<a name="Router.ServeHTTP"></a>
### func \(\*Router\) [ServeHTTP](<https://github.com/tigerwill90/fox/blob/master/fox.go#L531>)

```go
func (fox *Router) ServeHTTP(w http.ResponseWriter, r *http.Request)
```

ServeHTTP is the main entry point to serve a request. It handles all incoming HTTP requests and dispatches them to the appropriate handler function based on the request's method and path.

<a name="Router.Stats"></a>
### func \(\*Router\) [Stats](<https://github.com/tigerwill90/fox/blob/master/fox.go#L427>)

```go
func (fox *Router) Stats() RouterInfo
```

Stats returns information on the configured global option.

<a name="Router.Txn"></a>
### func \(\*Router\) [Txn](<https://github.com/tigerwill90/fox/blob/master/fox.go#L444>)

```go
func (fox *Router) Txn(write bool) *Txn
```

Txn create a new read\-write or read\-only transaction. Each [Txn](<#Txn>) must be finalized with [Txn.Commit](<#Txn.Commit>) or [Txn.Abort](<#Txn.Abort>). It's safe to create transaction from multiple goroutine and while the router is serving request. However, the returned [Txn](<#Txn>) itself is NOT tread\-safe. See also [Router.Updates](<#Router.Updates>) and [Router.View](<#Router.View>) for managed read\-write and read\-only transaction.

<details><summary>Example</summary>
<p>

This example demonstrate how to create an unmanaged read\-write transaction.

```go
f, _ := New()

// Txn create an unmanaged read-write or read-only transaction.
txn := f.Txn(true)
defer txn.Abort()

if _, err := txn.Handle(http.MethodGet, "exemple.com/hello/{name}", func(c Context) {
	_ = c.String(http.StatusOK, "hello %s", c.Param("name"))
}); err != nil {
	log.Printf("error inserting route: %s", err)
	return
}

// Iter returns a collection of range iterators for traversing registered routes.
it := txn.Iter()
// When Iter() is called on a write transaction, it creates a point-in-time snapshot of the transaction state.
// It means that writing on the current transaction while iterating is allowed, but the mutation will not be
// observed in the result returned by Prefix (or any other iterator).
for method, route := range it.Prefix(it.Methods(), "tmp.exemple.com/") {
	if _, err := f.Delete(method, route.Pattern()); err != nil {
		log.Printf("error deleting route: %s", err)
		return
	}
}
// Finalize the transaction
txn.Commit()
```

</p>
</details>

<a name="Router.Update"></a>
### func \(\*Router\) [Update](<https://github.com/tigerwill90/fox/blob/master/fox.go#L222>)

```go
func (fox *Router) Update(method, pattern string, handler HandlerFunc, opts ...RouteOption) (*Route, error)
```

Update override an existing route for the given method and pattern. On success, it returns the newly registered [Route](<#Route>). If an error occurs, it returns one of the following:

- [ErrRouteNotFound](<#ErrRouteNotFound>): If the route does not exist.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method or pattern is invalid.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.

Route\-specific option and middleware must be reapplied when updating a route. if not, any middleware and option will be removed, and the route will fall back to using global configuration \(if any\). It's safe to update a handler while the router is serving requests. This function is safe for concurrent use by multiple goroutine. To add new handler, use [Router.Handle](<#Router.Handle>) method.

<a name="Router.UpdateRoute"></a>
### func \(\*Router\) [UpdateRoute](<https://github.com/tigerwill90/fox/blob/master/fox.go#L241>)

```go
func (fox *Router) UpdateRoute(method string, route *Route) error
```

UpdateRoute override an existing [Route](<#Route>) for the given method and new [Route](<#Route>). If an error occurs, it returns one of the following:

- [ErrRouteNotFound](<#ErrRouteNotFound>): If the route does not exist.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method is invalid or the route is missing.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.

It's safe to update a handler while the router is serving requests. This function is safe for concurrent use by multiple goroutine. To add new route, use [Router.HandleRoute](<#Router.HandleRoute>) method.

<a name="Router.Updates"></a>
### func \(\*Router\) [Updates](<https://github.com/tigerwill90/fox/blob/master/fox.go#L394>)

```go
func (fox *Router) Updates(fn func(txn *Txn) error) error
```

Updates executes a function within the context of a read\-write managed transaction. If no error is returned from the function then the transaction is committed. If an error is returned then the entire transaction is aborted. Updates returns any error returned by fn. This function is safe for concurrent use by multiple goroutine and while the router is serving request. However [Txn](<#Txn>) itself is NOT tread\-safe. See also [Router.Txn](<#Router.Txn>) for unmanaged transaction and [Router.View](<#Router.View>) for managed read\-only transaction.

<details><summary>Example</summary>
<p>

This example demonstrate how to create a managed read\-write transaction.

```go
f, _ := New()

// Updates executes a function within the context of a read-write managed transaction. If no error is returned
// from the function then the transaction is committed. If an error is returned then the entire transaction is
// aborted.
if err := f.Updates(func(txn *Txn) error {
	if _, err := txn.Handle(http.MethodGet, "exemple.com/hello/{name}", func(c Context) {
		_ = c.String(http.StatusOK, "hello %s", c.Param("name"))
	}); err != nil {
		return err
	}

	// Iter returns a collection of range iterators for traversing registered routes.
	it := txn.Iter()
	// When Iter() is called on a write transaction, it creates a point-in-time snapshot of the transaction state.
	// It means that writing on the current transaction while iterating is allowed, but the mutation will not be
	// observed in the result returned by Prefix (or any other iterator).
	for method, route := range it.Prefix(it.Methods(), "tmp.exemple.com/") {
		if _, err := f.Delete(method, route.Pattern()); err != nil {
			return err
		}
	}
	return nil
}); err != nil {
	log.Printf("transaction aborted: %s", err)
}
```

</p>
</details>

<a name="Router.View"></a>
### func \(\*Router\) [View](<https://github.com/tigerwill90/fox/blob/master/fox.go#L414>)

```go
func (fox *Router) View(fn func(txn *Txn) error) error
```

View executes a function within the context of a read\-only managed transaction. View returns any error returned by fn. This function is safe for concurrent use by multiple goroutine and while mutation on routes are ongoing. However [Txn](<#Txn>) itself is NOT tread\-safe. See also [Router.Txn](<#Router.Txn>) for unmanaged transaction and [Router.Updates](<#Router.Updates>) for managed read\-write transaction.

<details><summary>Example</summary>
<p>

This example demonstrate how to create a managed read\-only transaction.

```go
f, _ := New()

// View executes a function within the context of a read-only managed transaction.
_ = f.View(func(txn *Txn) error {
	if txn.Has(http.MethodGet, "/foo") && txn.Has(http.MethodGet, "/bar") {
		// Do something
	}
	return nil
})
```

</p>
</details>

<a name="RouterInfo"></a>
## type [RouterInfo](<https://github.com/tigerwill90/fox/blob/master/fox.go#L120-L128>)

RouterInfo hold information on the configured global options.

```go
type RouterInfo struct {
    MaxRouteParams        uint16
    MaxRouteParamKeyBytes uint16
    MethodNotAllowed      bool
    AutoOptions           bool
    RedirectTrailingSlash bool
    IgnoreTrailingSlash   bool
    ClientIP              bool
}
```

<a name="TestContext"></a>
## type [TestContext](<https://github.com/tigerwill90/fox/blob/master/helpers.go#L12-L14>)



```go
type TestContext struct {
    // contains filtered or unexported fields
}
```

<a name="NewTestContextOnly"></a>
### func [NewTestContextOnly](<https://github.com/tigerwill90/fox/blob/master/helpers.go#L47>)

```go
func NewTestContextOnly(w http.ResponseWriter, r *http.Request, opts ...GlobalOption) *TestContext
```

NewTestContextOnly returns a new [Context](<#Context>) designed only for testing purpose.

<a name="TestContext.SetParams"></a>
### func \(\*TestContext\) [SetParams](<https://github.com/tigerwill90/fox/blob/master/helpers.go#L25>)

```go
func (c *TestContext) SetParams(params Params)
```

SetParams affect the provided params to this context.

<a name="TestContext.SetRoute"></a>
### func \(\*TestContext\) [SetRoute](<https://github.com/tigerwill90/fox/blob/master/helpers.go#L17>)

```go
func (c *TestContext) SetRoute(route *Route)
```

SetRoute affect the provided route to this context. It also set the [RouteHandler](<#RouteHandler>) scope.

<a name="TestContext.SetScope"></a>
### func \(\*TestContext\) [SetScope](<https://github.com/tigerwill90/fox/blob/master/helpers.go#L32>)

```go
func (c *TestContext) SetScope(scope HandlerScope)
```

SetScope affect the provided scope to this context.

<a name="Txn"></a>
## type [Txn](<https://github.com/tigerwill90/fox/blob/master/txn.go#L9-L13>)

Txn is a read or write transaction on the routing tree.

```go
type Txn struct {
    // contains filtered or unexported fields
}
```

<a name="Txn.Abort"></a>
### func \(\*Txn\) [Abort](<https://github.com/tigerwill90/fox/blob/master/txn.go#L324>)

```go
func (txn *Txn) Abort()
```

Abort cancel the transaction. This is a noop for read transactions, already aborted or committed transactions. This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs.

<a name="Txn.Commit"></a>
### func \(\*Txn\) [Commit](<https://github.com/tigerwill90/fox/blob/master/txn.go#L302>)

```go
func (txn *Txn) Commit()
```

Commit finalize the transaction. This is a noop for read transactions, already aborted or committed transactions. This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs.

<a name="Txn.Delete"></a>
### func \(\*Txn\) [Delete](<https://github.com/tigerwill90/fox/blob/master/txn.go#L149>)

```go
func (txn *Txn) Delete(method, pattern string) (*Route, error)
```

Delete deletes an existing route for the given method and pattern. On success, it returns the deleted [Route](<#Route>). If an error occurs, it returns one of the following:

- [ErrRouteNotFound](<#ErrRouteNotFound>): If the route does not exist.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method or pattern is invalid.
- [ErrReadOnlyTxn](<#ErrRouteNotFound>): On write in a read\-only transaction.

This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs.

<a name="Txn.Handle"></a>
### func \(\*Txn\) [Handle](<https://github.com/tigerwill90/fox/blob/master/txn.go#L25>)

```go
func (txn *Txn) Handle(method, pattern string, handler HandlerFunc, opts ...RouteOption) (*Route, error)
```

Handle registers a new route for the given method and pattern. On success, it returns the newly registered [Route](<#Route>). If an error occurs, it returns one of the following:

- [ErrRouteExist](<#ErrRouteNotFound>): If the route is already registered.
- [ErrRouteConflict](<#ErrRouteNotFound>): If the route conflicts with another.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method or pattern is invalid.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.
- [ErrReadOnlyTxn](<#ErrRouteNotFound>): On write in a read\-only transaction.

This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. To override an existing handler, use [Txn.Update](<#Txn.Update>).

<a name="Txn.HandleRoute"></a>
### func \(\*Txn\) [HandleRoute](<https://github.com/tigerwill90/fox/blob/master/txn.go#L60>)

```go
func (txn *Txn) HandleRoute(method string, route *Route) error
```

HandleRoute registers a new [Route](<#Route>) for the given method. If an error occurs, it returns one of the following:

- [ErrRouteExist](<#ErrRouteNotFound>): If the route is already registered.
- [ErrRouteConflict](<#ErrRouteNotFound>): If the route conflicts with another.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method is invalid or the route is missing.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.
- [ErrReadOnlyTxn](<#ErrRouteNotFound>): On write in a read\-only transaction.

This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. To override an existing route, use [Txn.UpdateRoute](<#Txn.UpdateRoute>).

<a name="Txn.Has"></a>
### func \(\*Txn\) [Has](<https://github.com/tigerwill90/fox/blob/master/txn.go#L191>)

```go
func (txn *Txn) Has(method, pattern string) bool
```

Has allows to check if the given method and route pattern exactly match a registered route. This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. See also [Txn.Route](<#Txn.Route>) as an alternative.

<a name="Txn.Iter"></a>
### func \(\*Txn\) [Iter](<https://github.com/tigerwill90/fox/blob/master/txn.go#L274>)

```go
func (txn *Txn) Iter() Iter
```

Iter returns a collection of range iterators for traversing registered routes. When called on a write transaction, Iter creates a point\-in\-time snapshot of the transaction state. Therefore, writing on the current transaction while iterating is allowed, but the mutation will not be observed in the result returned by iterators collection. This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs.

<a name="Txn.Len"></a>
### func \(\*Txn\) [Len](<https://github.com/tigerwill90/fox/blob/master/txn.go#L292>)

```go
func (txn *Txn) Len() int
```

Len returns the number of registered route.

<a name="Txn.Lookup"></a>
### func \(\*Txn\) [Lookup](<https://github.com/tigerwill90/fox/blob/master/txn.go#L245>)

```go
func (txn *Txn) Lookup(w ResponseWriter, r *http.Request) (route *Route, cc ContextCloser, tsr bool)
```

Lookup performs a manual route lookup for a given \[http.Request\], returning the matched [Route](<#Route>) along with a [ContextCloser](<#ContextCloser>), and a boolean indicating if the route was matched by adding or removing a trailing slash \(trailing slash action recommended\). If there is a direct match or a tsr is possible, Lookup always return a [Route](<#Route>) and a [ContextCloser](<#ContextCloser>). The [ContextCloser](<#ContextCloser>) should always be closed if non\-nil. This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. See also [Txn.Reverse](<#Txn.Reverse>) as an alternative.

<a name="Txn.Reverse"></a>
### func \(\*Txn\) [Reverse](<https://github.com/tigerwill90/fox/blob/master/txn.go#L224>)

```go
func (txn *Txn) Reverse(method, host, path string) (route *Route, tsr bool)
```

Reverse perform a reverse lookup for the given method, host and path and return the matching registered [Route](<#Route>) \(if any\) along with a boolean indicating if the route was matched by adding or removing a trailing slash \(trailing slash action recommended\). This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. See also [Txn.Lookup](<#Txn.Lookup>) as an alternative.

<a name="Txn.Route"></a>
### func \(\*Txn\) [Route](<https://github.com/tigerwill90/fox/blob/master/txn.go#L202>)

```go
func (txn *Txn) Route(method, pattern string) *Route
```

Route performs a lookup for a registered route matching the given method and route pattern. It returns the [Route](<#Route>) if a match is found or nil otherwise. This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. See also [Txn.Has](<#Txn.Has>) as an alternative.

<a name="Txn.Snapshot"></a>
### func \(\*Txn\) [Snapshot](<https://github.com/tigerwill90/fox/blob/master/txn.go#L343>)

```go
func (txn *Txn) Snapshot() *Txn
```

Snapshot returns a point in time snapshot of the current state of the transaction. Returns a new read\-only transaction or nil if the transaction is already aborted or commited.

<a name="Txn.Truncate"></a>
### func \(\*Txn\) [Truncate](<https://github.com/tigerwill90/fox/blob/master/txn.go#L177>)

```go
func (txn *Txn) Truncate(methods ...string) error
```

Truncate remove all routes for the provided methods. If no methods are provided, all routes are truncated. Truncating on a read\-only transaction returns ErrReadOnlyTxn.

<a name="Txn.Update"></a>
### func \(\*Txn\) [Update](<https://github.com/tigerwill90/fox/blob/master/txn.go#L88>)

```go
func (txn *Txn) Update(method, pattern string, handler HandlerFunc, opts ...RouteOption) (*Route, error)
```

Update override an existing route for the given method and pattern. On success, it returns the newly registered [Route](<#Route>). If an error occurs, it returns one of the following:

- [ErrRouteNotFound](<#ErrRouteNotFound>): If the route does not exist.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method or pattern is invalid.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.
- [ErrReadOnlyTxn](<#ErrRouteNotFound>): On write in a read\-only transaction.

Route\-specific option and middleware must be reapplied when updating a route. if not, any middleware and option will be removed, and the route will fall back to using global configuration \(if any\). This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. To add a new handler, use [Txn.Handle](<#Txn.Handle>).

<a name="Txn.UpdateRoute"></a>
### func \(\*Txn\) [UpdateRoute](<https://github.com/tigerwill90/fox/blob/master/txn.go#L125>)

```go
func (txn *Txn) UpdateRoute(method string, route *Route) error
```

UpdateRoute override an existing [Route](<#Route>) for the given method and new [Route](<#Route>). If an error occurs, it returns one of the following:

- [ErrRouteNotFound](<#ErrRouteNotFound>): If the route does not exist.
- [ErrInvalidRoute](<#ErrRouteNotFound>): If the provided method is invalid or the route is missing.
- [ErrInvalidConfig](<#ErrRouteNotFound>): If the provided route options are invalid.
- [ErrReadOnlyTxn](<#ErrRouteNotFound>): On write in a read\-only transaction.

This function is NOT thread\-safe and should be run serially, along with all other [Txn](<#Txn>) APIs. To add a new route, use [Txn.HandleRoute](<#Txn.HandleRoute>).

# clientip

```go
import "github.com/tigerwill90/fox/clientip"
```

## Index

- [Variables](<#variables>)
- [func AddressesAndRangesToIPNets\(ranges ...string\) \(\[\]net.IPNet, error\)](<#AddressesAndRangesToIPNets>)
- [func ParseIPAddr\(ip string\) \(\*net.IPAddr, error\)](<#ParseIPAddr>)
- [type BlacklistRangeOption](<#BlacklistRangeOption>)
  - [func ExcludeLinkLocal\(enable bool\) BlacklistRangeOption](<#ExcludeLinkLocal>)
  - [func ExcludeLoopback\(enable bool\) BlacklistRangeOption](<#ExcludeLoopback>)
  - [func ExcludePrivateNet\(enable bool\) BlacklistRangeOption](<#ExcludePrivateNet>)
- [type Chain](<#Chain>)
  - [func NewChain\(resolvers ...fox.ClientIPResolver\) Chain](<#NewChain>)
  - [func \(s Chain\) ClientIP\(c fox.Context\) \(\*net.IPAddr, error\)](<#Chain.ClientIP>)
- [type HeaderKey](<#HeaderKey>)
  - [func \(h HeaderKey\) String\(\) string](<#HeaderKey.String>)
- [type LeftmostNonPrivate](<#LeftmostNonPrivate>)
  - [func NewLeftmostNonPrivate\(key HeaderKey, limit uint, opts ...BlacklistRangeOption\) \(LeftmostNonPrivate, error\)](<#NewLeftmostNonPrivate>)
  - [func \(s LeftmostNonPrivate\) ClientIP\(c fox.Context\) \(\*net.IPAddr, error\)](<#LeftmostNonPrivate.ClientIP>)
- [type RemoteAddr](<#RemoteAddr>)
  - [func NewRemoteAddr\(\) RemoteAddr](<#NewRemoteAddr>)
  - [func \(s RemoteAddr\) ClientIP\(c fox.Context\) \(\*net.IPAddr, error\)](<#RemoteAddr.ClientIP>)
- [type RightmostNonPrivate](<#RightmostNonPrivate>)
  - [func NewRightmostNonPrivate\(key HeaderKey, opts ...TrustedRangeOption\) \(RightmostNonPrivate, error\)](<#NewRightmostNonPrivate>)
  - [func \(s RightmostNonPrivate\) ClientIP\(c fox.Context\) \(\*net.IPAddr, error\)](<#RightmostNonPrivate.ClientIP>)
- [type RightmostTrustedCount](<#RightmostTrustedCount>)
  - [func NewRightmostTrustedCount\(key HeaderKey, trustedCount uint\) \(RightmostTrustedCount, error\)](<#NewRightmostTrustedCount>)
  - [func \(s RightmostTrustedCount\) ClientIP\(c fox.Context\) \(\*net.IPAddr, error\)](<#RightmostTrustedCount.ClientIP>)
- [type RightmostTrustedRange](<#RightmostTrustedRange>)
  - [func NewRightmostTrustedRange\(key HeaderKey, resolver TrustedIPRange\) \(RightmostTrustedRange, error\)](<#NewRightmostTrustedRange>)
  - [func \(s RightmostTrustedRange\) ClientIP\(c fox.Context\) \(\*net.IPAddr, error\)](<#RightmostTrustedRange.ClientIP>)
- [type SingleIPHeader](<#SingleIPHeader>)
  - [func NewSingleIPHeader\(headerName string\) \(SingleIPHeader, error\)](<#NewSingleIPHeader>)
  - [func \(s SingleIPHeader\) ClientIP\(c fox.Context\) \(\*net.IPAddr, error\)](<#SingleIPHeader.ClientIP>)
- [type TrustedIPRange](<#TrustedIPRange>)
- [type TrustedIPRangeFunc](<#TrustedIPRangeFunc>)
  - [func \(f TrustedIPRangeFunc\) TrustedIPRange\(\) \(\[\]net.IPNet, error\)](<#TrustedIPRangeFunc.TrustedIPRange>)
- [type TrustedRangeOption](<#TrustedRangeOption>)
  - [func TrustLinkLocal\(enable bool\) TrustedRangeOption](<#TrustLinkLocal>)
  - [func TrustLoopback\(enable bool\) TrustedRangeOption](<#TrustLoopback>)
  - [func TrustPrivateNet\(enable bool\) TrustedRangeOption](<#TrustPrivateNet>)


## Variables

<a name="ErrInvalidIpAddress"></a>

```go
var (
    ErrInvalidIpAddress      = errors.New("invalid ip address")
    ErrUnspecifiedIpAddress  = errors.New("unspecified ip address")
    ErrRemoteAddress         = errors.New("remote address resolver")
    ErrSingleIPHeader        = errors.New("single ip header resolver")
    ErrLeftmostNonPrivate    = errors.New("leftmost non private resolver")
    ErrRightmostNonPrivate   = errors.New("rightmost non private resolver")
    ErrRightmostTrustedCount = errors.New("rightmost trusted count resolver")
    ErrRightmostTrustedRange = errors.New("rightmost trusted range resolver")
)
```

<a name="AddressesAndRangesToIPNets"></a>
## func [AddressesAndRangesToIPNets](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L384>)

```go
func AddressesAndRangesToIPNets(ranges ...string) ([]net.IPNet, error)
```

AddressesAndRangesToIPNets converts a slice of strings with IPv4 and IPv6 addresses and CIDR ranges \(prefixes\) to [net.IPNet](<https://pkg.go.dev/net/#IPNet>) instances. If [net.ParseCIDR](<https://pkg.go.dev/net/#ParseCIDR>) or [net.ParseIP](<https://pkg.go.dev/net/#ParseIP>) fail, an error will be returned. Zones in addresses or ranges are not allowed and will result in an error.

<a name="ParseIPAddr"></a>
## func [ParseIPAddr](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L350>)

```go
func ParseIPAddr(ip string) (*net.IPAddr, error)
```

ParseIPAddr safely parses the given string into a [net.IPAddr](<https://pkg.go.dev/net/#IPAddr>). It also returns an error for unspecified \(like "::"\) and zero\-value addresses \(like "0.0.0.0"\). These are nominally valid IPs \([net.ParseIP](<https://pkg.go.dev/net/#ParseIP>) will accept them\), but they are never valid "real" client IPs.

The function returns the following errors: \- [ErrInvalidIpAddress](<#ErrInvalidIpAddress>): if the IP address cannot be parsed. \- [ErrUnspecifiedIpAddress](<#ErrInvalidIpAddress>): if the IP address is unspecified \(e.g., "::" or "0.0.0.0"\).

<a name="BlacklistRangeOption"></a>
## type [BlacklistRangeOption](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L15-L17>)



```go
type BlacklistRangeOption interface {
    // contains filtered or unexported methods
}
```

<a name="ExcludeLinkLocal"></a>
### func [ExcludeLinkLocal](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L68>)

```go
func ExcludeLinkLocal(enable bool) BlacklistRangeOption
```

ExcludeLinkLocal enables or disables the inclusion of link local ip ranges in the blacklisted ip ranges.

<a name="ExcludeLoopback"></a>
### func [ExcludeLoopback](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L59>)

```go
func ExcludeLoopback(enable bool) BlacklistRangeOption
```

ExcludeLoopback enables or disables the inclusion of loopback ip ranges in the blacklisted ip ranges.

<a name="ExcludePrivateNet"></a>
### func [ExcludePrivateNet](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L77>)

```go
func ExcludePrivateNet(enable bool) BlacklistRangeOption
```

ExcludePrivateNet enables or disables the inclusion of private\-space ip ranges in the blacklisted ip ranges.

<a name="Chain"></a>
## type [Chain](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L77-L79>)

Chain attempts to use the given resolvers in order. If the first one returns an error, the second one is tried, and so on, until a good IP is found or the resolvers are exhausted. A common use for this is if a server is both directly connected to the internet and expecting a header to check. It might be called like:

```
var chain = NewChain(NewLeftmostNonPrivate(XForwardedForKey), NewRemoteAddr())
```

```go
type Chain struct {
    // contains filtered or unexported fields
}
```

<a name="NewChain"></a>
### func [NewChain](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L83>)

```go
func NewChain(resolvers ...fox.ClientIPResolver) Chain
```

NewChain creates a [Chain](<#Chain>) that attempts to use the given resolvers to derive the client IP, stopping when the first one succeeds.

<a name="Chain.ClientIP"></a>
### func \(Chain\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L88>)

```go
func (s Chain) ClientIP(c fox.Context) (*net.IPAddr, error)
```

ClientIP try to derive the client IP using this resolver chain.

<a name="HeaderKey"></a>
## type [HeaderKey](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L61>)



```go
type HeaderKey uint8
```

<a name="XForwardedForKey"></a>

```go
const (
    XForwardedForKey HeaderKey = iota
    ForwardedKey
)
```

<a name="HeaderKey.String"></a>
### func \(HeaderKey\) [String](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L63>)

```go
func (h HeaderKey) String() string
```



<a name="LeftmostNonPrivate"></a>
## type [LeftmostNonPrivate](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L166-L170>)

LeftmostNonPrivate derives the client IP from the leftmost valid and non\-private/non\-internal IP address in the X\-Forwarded\-For or Forwarded header. This resolver should be used when a valid, non\-private IP closest to the client is desired. By default, loopback, link local and private net ip range are blacklisted. Note that this MUST NOT BE USED FOR SECURITY PURPOSES. This IP can be TRIVIALLY SPOOFED.

```go
type LeftmostNonPrivate struct {
    // contains filtered or unexported fields
}
```

<a name="NewLeftmostNonPrivate"></a>
### func [NewLeftmostNonPrivate](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L175>)

```go
func NewLeftmostNonPrivate(key HeaderKey, limit uint, opts ...BlacklistRangeOption) (LeftmostNonPrivate, error)
```

NewLeftmostNonPrivate creates a [LeftmostNonPrivate](<#LeftmostNonPrivate>) resolver. By default, loopback, link local and private net ip range are blacklisted. A reasonable limit on the number of IPs to parse must be provided to prevent excessive resource usage from adversarial headers.

<a name="LeftmostNonPrivate.ClientIP"></a>
### func \(LeftmostNonPrivate\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L197>)

```go
func (s LeftmostNonPrivate) ClientIP(c fox.Context) (*net.IPAddr, error)
```

ClientIP derives the client IP using the [LeftmostNonPrivate](<#LeftmostNonPrivate>) resolver. The returned [net.IPAddr](<https://pkg.go.dev/net/#IPAddr>) may contain a zone identifier. If no valid IP can be derived, an error returned.

<a name="RemoteAddr"></a>
## type [RemoteAddr](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L103>)

RemoteAddr returns the client socket IP, stripped of port. This resolver should be used if the server accept direct connections, rather than through a reverse proxy.

```go
type RemoteAddr struct{}
```

<a name="NewRemoteAddr"></a>
### func [NewRemoteAddr](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L106>)

```go
func NewRemoteAddr() RemoteAddr
```

NewRemoteAddr that uses request remote address to get the client IP.

<a name="RemoteAddr.ClientIP"></a>
### func \(RemoteAddr\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L113>)

```go
func (s RemoteAddr) ClientIP(c fox.Context) (*net.IPAddr, error)
```

ClientIP derives the client IP using the [RemoteAddr](<#RemoteAddr>) resolver. The returned [net.IPAddr](<https://pkg.go.dev/net/#IPAddr>) may contain a zone identifier. This should only happen if the remote address has been modified to something illegal, or if the server is accepting connections on a Unix domain socket \(in which case [RemoteAddr](<#RemoteAddr>) is "@"\). If no valid IP can be derived, an error is returned.

<a name="RightmostNonPrivate"></a>
## type [RightmostNonPrivate](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L213-L216>)

RightmostNonPrivate derives the client IP from the rightmost valid, non\-private/non\-internal IP address in the X\-Fowarded\-For or Forwarded header. This resolver should be used when all reverse proxies between the internet and the server have private\-space IP addresses. By default, loopback, link local and private net ip range are trusted.

```go
type RightmostNonPrivate struct {
    // contains filtered or unexported fields
}
```

<a name="NewRightmostNonPrivate"></a>
### func [NewRightmostNonPrivate](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L220>)

```go
func NewRightmostNonPrivate(key HeaderKey, opts ...TrustedRangeOption) (RightmostNonPrivate, error)
```

NewRightmostNonPrivate creates a [RightmostNonPrivate](<#RightmostNonPrivate>) resolver. By default, loopback, link local and private net ip range are trusted.

<a name="RightmostNonPrivate.ClientIP"></a>
### func \(RightmostNonPrivate\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L238>)

```go
func (s RightmostNonPrivate) ClientIP(c fox.Context) (*net.IPAddr, error)
```

ClientIP derives the client IP using the [RightmostNonPrivate](<#RightmostNonPrivate>) resolver. The returned [net.IPAddr](<https://pkg.go.dev/net/#IPAddr>) may contain a zone identifier. If no valid IP can be derived, an error returned.

<a name="RightmostTrustedCount"></a>
## type [RightmostTrustedCount](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L253-L256>)

RightmostTrustedCount derives the client IP from the valid IP address added by the first trusted reverse proxy to the X\-Forwarded\-For or Forwarded header. This resolver should be used when there is a fixed number of trusted reverse proxies that are appending IP addresses to the header.

```go
type RightmostTrustedCount struct {
    // contains filtered or unexported fields
}
```

<a name="NewRightmostTrustedCount"></a>
### func [NewRightmostTrustedCount](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L261>)

```go
func NewRightmostTrustedCount(key HeaderKey, trustedCount uint) (RightmostTrustedCount, error)
```

NewRightmostTrustedCount creates a [RightmostTrustedCount](<#RightmostTrustedCount>) resolver. trustedCount is the number of trusted reverse proxies. The IP returned will be the \(trustedCount\-1\)th from the right. For example, if there's only one trusted proxy, this resolver will return the last \(rightmost\) IP address.

<a name="RightmostTrustedCount.ClientIP"></a>
### func \(RightmostTrustedCount\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L274>)

```go
func (s RightmostTrustedCount) ClientIP(c fox.Context) (*net.IPAddr, error)
```

ClientIP derives the client IP using the [RightmostTrustedCount](<#RightmostTrustedCount>) resolver. The returned [net.IPAddr](<https://pkg.go.dev/net/#IPAddr>) may contain a zone identifier. If no valid IP can be derived, an error returned.

<a name="RightmostTrustedRange"></a>
## type [RightmostTrustedRange](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L297-L300>)

RightmostTrustedRange derives the client IP from the rightmost valid IP address in the X\-Forwarded\-For or Forwarded header which is not in a set of trusted IP ranges. This resolver should be used when the IP ranges of the reverse proxies between the internet and the server are known. If a third\-party WAF, CDN, etc., is used, you SHOULD use a method of verifying its access to your origin that is stronger than checking its IP address \(e.g., using authenticated pulls\). Failure to do so can result in scenarios like: You use AWS CloudFront in front of a server you host elsewhere. An attacker creates a CF distribution that points at your origin server. The attacker uses Lambda@Edge to spoof the Host and X\-Forwarded\-For headers. Now your "trusted" reverse proxy is no longer trustworthy.

```go
type RightmostTrustedRange struct {
    // contains filtered or unexported fields
}
```

<a name="NewRightmostTrustedRange"></a>
### func [NewRightmostTrustedRange](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L305>)

```go
func NewRightmostTrustedRange(key HeaderKey, resolver TrustedIPRange) (RightmostTrustedRange, error)
```

NewRightmostTrustedRange creates a [RightmostTrustedRange](<#RightmostTrustedRange>) resolver. headerName must be "X\-Forwarded\-For" or "Forwarded". trustedRanges must contain all trusted reverse proxies on the path to this server and can be private/internal or external \(for example, if a third\-party reverse proxy is used\).

<a name="RightmostTrustedRange.ClientIP"></a>
### func \(RightmostTrustedRange\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L319>)

```go
func (s RightmostTrustedRange) ClientIP(c fox.Context) (*net.IPAddr, error)
```

ClientIP derives the client IP using the [RightmostTrustedRange](<#RightmostTrustedRange>) resolver. The returned [net.IPAddr](<https://pkg.go.dev/net/#IPAddr>) may contain a zone identifier. If no valid IP can be derived, an error is returned.

<a name="SingleIPHeader"></a>
## type [SingleIPHeader](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L126-L128>)

SingleIPHeader derives an IP address from a single\-IP header. A non\-exhaustive list of such single\-IP headers is: X\-Real\-IP, CF\-Connecting\-IP, True\-Client\-IP, Fastly\-Client\-IP, X\-Azure\-ClientIP, X\-Azure\-SocketIP. This resolver should be used when the given header is added by a trusted reverse proxy. You must ensure that this header is not spoofable \(as is possible with Akamai's use of True\-Client\-IP, Fastly's default use of Fastly\-Client\-IP, and Azure's X\-Azure\-ClientIP\).

```go
type SingleIPHeader struct {
    // contains filtered or unexported fields
}
```

<a name="NewSingleIPHeader"></a>
### func [NewSingleIPHeader](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L131>)

```go
func NewSingleIPHeader(headerName string) (SingleIPHeader, error)
```

NewSingleIPHeader creates a [SingleIPHeader](<#SingleIPHeader>) resolver that uses the headerName request header to get the client IP.

<a name="SingleIPHeader.ClientIP"></a>
### func \(SingleIPHeader\) [ClientIP](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L147>)

```go
func (s SingleIPHeader) ClientIP(c fox.Context) (*net.IPAddr, error)
```

ClientIP derives the client IP using the [SingleIPHeader](<#SingleIPHeader>) resolver. The returned [net.IPAddr](<https://pkg.go.dev/net/#IPAddr>) may contain a zone identifier. If no valid IP can be derived, an error is returned.

<a name="TrustedIPRange"></a>
## type [TrustedIPRange](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L46-L48>)

TrustedIPRange returns a set of trusted IP ranges. Implementations of this interface must be thread\-safe as it will be invoked whenever the client IP needs to be resolved, potentially from multiple goroutines.

```go
type TrustedIPRange interface {
    TrustedIPRange() ([]net.IPNet, error)
}
```

<a name="TrustedIPRangeFunc"></a>
## type [TrustedIPRangeFunc](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L54>)

The TrustedIPRangeFunc type is an adapter to allow the use of ordinary functions as [TrustedIPRange](<#TrustedIPRange>). If f is a function with the appropriate signature, TrustedIPRangeFunc\(\) is a [TrustedIPRange](<#TrustedIPRange>) that calls f.

```go
type TrustedIPRangeFunc func() ([]net.IPNet, error)
```

<a name="TrustedIPRangeFunc.TrustedIPRange"></a>
### func \(TrustedIPRangeFunc\) [TrustedIPRange](<https://github.com/tigerwill90/fox/blob/master/clientip/clientip.go#L57>)

```go
func (f TrustedIPRangeFunc) TrustedIPRange() ([]net.IPNet, error)
```

TrustedIPRange calls f\(\).

<a name="TrustedRangeOption"></a>
## type [TrustedRangeOption](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L11-L13>)



```go
type TrustedRangeOption interface {
    // contains filtered or unexported methods
}
```

<a name="TrustLinkLocal"></a>
### func [TrustLinkLocal](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L41>)

```go
func TrustLinkLocal(enable bool) TrustedRangeOption
```

TrustLinkLocal enables or disables the inclusion of link local ip ranges in the trusted ip ranges.

<a name="TrustLoopback"></a>
### func [TrustLoopback](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L32>)

```go
func TrustLoopback(enable bool) TrustedRangeOption
```

TrustLoopback enables or disables the inclusion of loopback ip ranges in the trusted ip ranges.

<a name="TrustPrivateNet"></a>
### func [TrustPrivateNet](<https://github.com/tigerwill90/fox/blob/master/clientip/options.go#L50>)

```go
func TrustPrivateNet(enable bool) TrustedRangeOption
```

TrustPrivateNet enables or disables the inclusion of private\-space ip ranges in the trusted ip ranges.

# signals

```go
import "github.com/tigerwill90/fox/signals"
```

## Index

- [func SetupHandler\(\) context.Context](<#SetupHandler>)


<a name="SetupHandler"></a>
## func [SetupHandler](<https://github.com/tigerwill90/fox/blob/master/signals/signal.go#L31>)

```go
func SetupHandler() context.Context
```

SetupHandler registered for SIGTERM and SIGINT. A context is returned which is cancelled on one of these signals. If a second signal is caught, the program is terminated with exit code 1.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
